\chapter{Review und Ausblick}\label{review}
\section{Was leistet das Tool?}
Die Auswertung der Garbage Collection während einer Performance Analyse wird gemacht wenn man weiss, dass die CPU-Last gross ist, aber nicht durch das System respektive den Kernel verursacht wird. Sprich, der Dominating Consumer ist die Java Virtual Machine (siehe Abschnitt \titleref{dominating_consumer} auf Seite \pageref{dominating_consumer}).

In der Folge nun einige Punkte wie die Software für Analysezwecke verwendet werden kann.

\subsection{Offline-Analyse}
Zur Auswertung einer laufenden Virtuellen Machine wird bevorzugt JRockit Mission Control verwendet. Darin kann die Garbage Collection einer laufenden JRockit analysiert werden. \textit{Mit der Bedingung, dass es keine Firewall-Einschränkungen für die Verbindung auf den Server gibt.} \textbf{Die Analysesoftware macht dann Sinn, wenn man eine Log-Datei über einen Zeitraum erstellt hat und dann Analysen auf Basis dieser Log-Datei durchführen kann.}

\subsection{Inhalt der Log-Datei}
Aktuell werden die Log-Einträge des \textbf{Memory-Moduls  (Log-Level: INFO) der JRockit Virtual Machine R28} ausgewertet. Das sind die wichtigsten Ausgaben die im Zusammenhang mit der Garbage Collection geschrieben werden - aber nicht alle. Um eine Auswertung einer Log-Datei zu machen, muss das Logging für das Memory-Modul über das Argument -Xverbose:memory aktiviert werden.

\section{Erweiterungen (Möglichkeiten)}
\subsection{Analyseumfangs JRockit R28}\label{analyseumfang_jr28}
Aktuell werden nur die Log-Einträge des Memory-Moduls (Log-Level: INFO) berücksichtigt. Wie der nachfolgende Auszug einer Log-Datei zeigt, gäbe aus den Debug-Informationen spannende Dinge die momentan nicht ausgewertet werden:

\begin{itemize}
	\item \textbf{Gründe, warum eine Garbage Collection gestartet wurde:  }Die erste Zeile zeigt, dass es hängige Anfragen für die Allokation von Speicher gibt.
	\item \textbf{Dauer der einzelnen Garbage Collection Phasen (Initial Marking, Precleaning, Final Marking): } Nicht alle dieser Phasen laufen beispielsweise konkurrierend ab. Im Sinne von möglichst kurzen Pausenzeiten ist es deshalb interessant, wie lange die Final Marking Phase dauert. 
\end{itemize}

\begin{lstlisting}[caption=Garbage Collection Log (Debug Informationen)]
[INFO ][alloc  ] [OC#1] Satisfied 0 object and 0 tla allocations. Pending requests went from 1 to 1.
[DEBUG][memory ] [OC#1] Initial marking phase promoted 3620 objects (206KB).
[DEBUG][memory ] [OC#1] Starting concurrent marking phase (OC2).
[DEBUG][memory ] [OC#1] Concurrent mark phase lasted 0.235 ms.
[DEBUG][memory ] [OC#1] Starting precleaning phase (OC3).
[DEBUG][memory ] [OC#1] Precleaning phase lasted 0.249 ms.
[DEBUG][memory ] [OC#1] Starting final marking phase (OC4).
[INFO ][nursery] [OC#1] Young collection started. This YC is a part of OC#1 final marking.
\end{lstlisting}

\subsection{Analyseumfangs JRockit R27}\label{analyseumfang_jr27}
Wie bereits erwähnt können die Logs der Version R27 noch nicht ausgewertet werden, obwohl diese Version noch an einigen Orten verwendet wird. Ziel wäre die möglichst rasche Kompatibilität zur Version R27.

\subsection{G1 Algorithmus}
Ab Version 1.6.0\_14 des Java Runtime Environments ist eine Vorversion des G1 Garbage Collectors\footnote{G1 ist auch unter dem Namen Garbage First Garbage Collector bekannt.} verfügbar. Die Funktionsweise dieses Algorithmus unterscheidet sich stark von den bisherigen Versionen des Mark \& Seep Algorithmus, auch die Log-Dateien werden markante Unterschiede aufweisen. Für die Auswertung solcher Dateien gibt es aktuell noch kein Werkzeug, die Implementation dieses Formats wäre aus diesem Grund noch sehr interessant.







