\chapter{Review und Ausblick}\label{review}
\section{Was leistet das Tool?}
Während einer Performanceanalyse kommt es zur Auswertung der Garbage Collection, wenn die CPU-Last hoch ist, aber nicht durch den Kernel (Systemprozess) verursacht wird. Der Dominating Consumer ist dann die Java Virtual Machine (siehe Abschnitt \titleref{dominating_consumer} auf Seite \pageref{dominating_consumer}). Die folgenden Abschnitte zeigen wann und wie die Analysesoftware verwendet werden kann.

\subsection{Offline-Analyse}
Zur Auswertung einer laufenden Virtuellen Machine, kann auch die Software JRockit Mission Control von Oracle verwendet werden. Oft ist allerdings der Zugriff via Mission Control auf den Server nicht möglich - es gibt Firewall-Regeln oder man befindet sich ausserhalb des Netzwerkes. In diesem Fall müssen zur Analyse die erstellten Garbage Collection Logdateien verwendet werden. \textbf{Mit der Analysesoftware kann diese Aufgabe vereinfacht werden indem sie die gesammelten Daten visualisiert.}

\subsection{Log Module}
Aktuell werden die Log-Einträge des \textbf{Memory-Moduls  (Log-Level: INFO)} ausgewertet. Das sind die wichtigsten Ausgaben die im Zusammenhang mit der Garbage Collection geschrieben werden - aber nicht alle. Um eine Auswertung einer Logdatei zu machen, muss das Logging für das Memory-Modul über das Argument -Xverbose:memory aktiviert werden.

\subsection{JRockit Version}
Version R28 ist die neuste Version der JRockit. Die Analysesoftware wurde auf das Format dieser Virutellen Machine ausgerichtet. Die Analyse von Logdateien älterer Versionen ist momentan noch nicht möglich.

\section{Ausblick}
\subsection{Analyseumfangs JRockit R28}\label{analyseumfang_jr28}
Aktuell werden nur die Log-Einträge des Memory-Moduls (Log-Level: INFO) berücksichtigt. Wie der nachfolgende Auszug einer Logdatei zeigt, würden in den Debug-Einträgen spannende und teilweise wichtige Informationen stehen:
\begin{itemize}
	\item \textbf{Gründe, warum eine Garbage Collection gestartet wurde:  }Die erste Zeile zeigt, dass es hängige Anfragen für die Allokation von Speicher gibt.
	\item \textbf{Dauer der einzelnen Garbage Collection Phasen (Initial Marking, Precleaning, Final Marking): } Nicht alle dieser Phasen laufen beispielsweise konkurrierend ab. Im Sinne von möglichst kurzen Pausenzeiten ist es deshalb interessant, wie lange die Final Marking Phase dauert. 
\end{itemize}

\begin{lstlisting}[caption=Garbage Collection Log (Debug Informationen)]
[INFO ][alloc  ] [OC#1] Satisfied 0 object and 0 tla allocations. Pending requests went from 1 to 1.
[DEBUG][memory ] [OC#1] Initial marking phase promoted 3620 objects (206KB).
[DEBUG][memory ] [OC#1] Starting concurrent marking phase (OC2).
[DEBUG][memory ] [OC#1] Concurrent mark phase lasted 0.235 ms.
[DEBUG][memory ] [OC#1] Starting precleaning phase (OC3).
[DEBUG][memory ] [OC#1] Precleaning phase lasted 0.249 ms.
[DEBUG][memory ] [OC#1] Starting final marking phase (OC4).
[INFO ][nursery] [OC#1] Young collection started. This YC is a part of OC#1 final marking.
\end{lstlisting}

\subsection{Analyseumfangs JRockit R27}\label{analyseumfang_jr27}
Wie bereits erwähnt, können die Logs der Version R27 noch nicht ausgewertet werden, obwohl diese Version noch an einigen Orten im Einsatz ist. Ziel wäre die möglichst rasche Kompatibilität zur Version R27.

\subsection{G1 Algorithmus}
Ab Version 1.6.0\_14 des Java Runtime Environments ist eine Vorversion des G1 Garbage Collectors\footnote{G1 ist auch unter dem Namen Garbage First Garbage Collector bekannt.} verfügbar. Die Funktionsweise dieses Algorithmus unterscheidet sich stark von den bisherigen Versionen des Mark \& Sweep Algorithmus, auch die Logdateien weisen Unterschiede auf. Für die Auswertung solcher Dateien gibt es aktuell noch kein Werkzeug, die Implementation dieses Formats wäre deshalb spannend.







