\chapter{Grundlagen Garbage Collection in der JRockit Virtual Machine}\label{jrockit garbage collection}
\section{Grundlage}
Die Grundlage der JRockit Garbage Collection bildet der Tri-Coloring Mark \& Sweep Algorithmus (siehe Abschnitt \titleref{tri-coloring mark and sweep}). Er wurde hinsichtlich besserer Parallelisierbarkeit und der optimalen Verwendung der Anzahl Threads optimiert. Die Garbage Collection der JRockit VM kann mit oder ohne Generationen arbeiten - so gibt es die beiden Algorithmen ``Concurrent Mark \& Sweep'' und ``Parallel Mark \& Sweep'' in beiden Ausführungen Generational und Single:

\begin{itemize}
	\item Generational Concurrent Mark \& Sweep
	\item Single Concurrent Mark \& Sweep
	\item Generational Parallel Mark \& Sweep	
	\item Single Parallel Mark \& Sweep
\end{itemize}

\subsection{Garbage Collection Algorithmus}
Im Unterschied zum normalen Tri-Coloring Algorithmus verwendet der Algorithmus der JRockit, egal ob parallel oder concurrent, zwei Sets für die Markierung der Objekte. In einem werden die grauen und schwarzen Objekte gespeichert, im anderen die weissen. Die Trennung zwischen Grau und Schwarz wird gemacht indem die grauen Objekte in Thread-Local Queues jedes Garbage Collection Threads gespeichert werden. 

Die Verwendung von Thread-lokalem Speicher hat hinsichtlich den folgenden Punkten einen Vorteil:\cite[S. 79]{lagergren2010oracle}:
\begin{itemize}
	\item Thread-lokaler Speicher führt zu einer besseren Parallelisierbarkeit.
	\item Thread-lokaler Speicher kann prefetched werden, was die Geschwindigkeit des Algorithmus als Ganzes erhöht.
\end{itemize}

Bei der Verwendung der Concurrent Algorithmen wird parallel dazu auch Speicher für neue Objekte alloziert. Diese neuen Objekte werden in einem sogenannten Live-Set getrackt, damit sie in der Sweep Phase - obwohl nicht markiert - nicht gelöscht werden.

\subsubsection{Generationen}
Die Idee der Generational Garbage Collection ist, dass während einer Young Collection nur ein Teilbereich des Heaps aufgeräumt wird. Referenzen in die Old Collection werden dabei nicht verfolgt. Den Referenzen von der Old in die Young Collection muss trotzdem nachgegangen werden, sie können auf unterschiedliche Weise entstehen:
\begin{itemize}
	\item \textbf{Ein Objekt wird durch eine Promotion von der Young Generation in die Old Generation verschoben:} Die Dabei entstehenden intergenerationellen Referenzen werden im sogenannten \textbf{Remembered Set} nachgeführt. 
	\item \textbf{Es findet eine Zuweisung der Referenz durch die Applikation statt:} Diese Problematik wird durch Write Barriers und der Aufteilung des Heaps in sogenannte Cards\footnote{Eine Card ist typischerweise ein ungefähr 512 Byte grosser Bereich auf dem Heap.} gemacht. Bei der Änderung einer Referenz (die dann von der Old in die Young Collection zeigt) wird auf der entsprechenden Card das ``Dirty Bit'' gesetzt. Objekte innerhalb von dirty Cards werden nach der Markierungsphase nochmals überprüft.
\end{itemize}

\subsubsection{Nebenläufigkeit}
Beim Concurrent Mark \& Sweep handelt es sich eigentlich um einen Mostly Concurrent Mark \& Sweep Algorithmus. Das heisst er findet nicht in allen Phasen konkurrierend zur Applikation statt. Die Markierung dieses Algorithmus ist in vier Phasen aufgeteilt:
\begin{itemize}
	\item \textbf{Initial Marking (Nicht konkurrierend):} Hier wird das Root Set zusammengestellt.
	\item \textbf{Concurrent Marking (konkurrierend):} Mehrere Threads gehen nun diesen Referenzen nach und markieren Sie als lebende Objekte.
	\item \textbf{Preclean (konkurrierend): Änderungen im Heap während den vorherigen Schritten werden nachgeführt, markiert.}
	\item \textbf{Final Marking (Nicht konkurrierend):} Änderungen im Heap während der Precleaning Phase werden nachgeführt, markiert.
\end{itemize}

Die Sweep Phase findet ebenfalls konkurrierend zur Applikation statt. Im Gegensatz zur HotSpot VM ist sie aber in zwei Schritte aufgeteilt. Als erstes wird die erste Hälfte des Heaps von toten Objekten befreit. Während dieser Phase können Threads Speicher in der zweiten Hälfte des Heaps allozieren. Nach einer kurzen Synchronisationspause findet das Sweeping auf dem zweiten Teil des Heaps statt.

\subsubsection{Parallelität}
Beim parallelen Mark \& Sweep findet die Garbage Collection parallel mit allen verfügbaren Prozessoren statt. Dazu werden aber alle Threads der Applikation gestoppt.

\subsubsection{Kompaktierung}
Aufgrund der im Speicher stattfindenden Fragmentierung wird bei jeder Old Collection eine Kompaktierung des Speichers durchgeführt. Während der Sweep Phase werden die Objekte auf dem Heap umherkopiert, so dass danach wieder grössere Speicherbereiche am Stück existieren.


\section{Übersicht der Garbage Collection Algorithmen auf der JRockit Virtual Machine}
\subsection{Garbage Collection Modi}
Die Auswahl der Garbage Collection Strategie muss auf der Basis der Anforderungen an die Applikation gemacht werden. Auf der JRockit VM gibt es drei verschiedene Modi:
\begin{itemize}
	\item \textbf{Durchsatz (throughput):} Optimiert die Garbage Collection hinsichtlich möglichst grossem Durchsatz. Um dieses Ziel zu erreichen, werden parallele Algorithmen verwendet. Sie laufen nicht-konkurrierend mit der Applikation und führen zu kurzen Pausenzeiten (Stop-the-World Pausen). In der restlichen Zeit stehen der Applikation allerdings sehr viel Ressourcen zur Verfügung.
	\item \textbf{Pausenzeit (pause time):} Die Optimierung der Pausenzeiten hat zur Folge, dass die Applikation durch möglichst wenig Stop-the-World Pausen angehalten wird. Das ist insbesondere für Client-Server Applikationen wichtig. Das Ziel wird mit der Verwendung eines Concurrent Garbage Collection Algorithmus erreicht.
	\item \textbf{Determinismus (deterministic):} Optimiert den Garbage Collector auf sehr kurze und deterministische Garbage Collection Pausen.  
\end{itemize}
  \begin{longtable}{|p{2.5cm}|p{3.1cm}|p{4.5cm}|p{4cm}|}\hline
  \textbf{Alias} & \textbf{Aktivierung} & \textbf{Beschreibung} & Einstellungsmöglichkeiten\\\hline
  troughput & -Xgc:throughput & Der Garbage Collector wird auf maximalen Durchsatz der Applikation eingestellt. Er arbeitet so effektiv wie möglich und erhält entsprechend viele Java-Threads, was zu kurzen Pausen der Applikation führen kann. & \\\hline
  pausetime & -Xgc:pausetime & Der Garbage Collector wird auf möglichst kurze Pausen eingestellt. Das bedeutet, dass ein konkurrierender Algorithmus verwendet wird, der insgesamt etwas mehr CPU Ressourcen benötigt. & -XpauseTarget=value (default 200msec)\\\hline
  deterministic & -Xgc:deterministic & Der Garbage Collector wird auf eine möglichst kurze und deterministische Pausenzeit eingestellt. &-XpauseTarget=value (default 30msec)\\\hline
    \caption{Übersicht der Garbage Collection Modi}
\end{longtable}

\subsection{Garbage Collection Algorithmen}
  \begin{longtable}{|p{2cm}|p{2.8cm}|l|c|c|c|c|c|}
    \hline
  \textbf{Alias} & \textbf{Aktivierung}& \textbf{Generation} & \textbf{Pause} &\textbf{Durchs.} & \textbf{Heap} & \textbf{Mark} & \textbf{Sweep} \\\hline
  singlecon, singleconcon & -Xgc:singlecon\newline-Xgc:singleconcon& - &++&--& single & konk. & konk\\\hline

  gencon,\newline genconcon& -Xgc:gencon\newline-Xgc:genconcon &Old, Young&++&-- & gen & konk. & konk.\\\hline	
 
  singlepar, \newline singleparpar& -Xgc:singlepar\newline-Xgc:singleparpar & - & -- & ++ & single & parallel & parallel \\\hline
  genpar, \newline genparpar& -Xgc:genpar\newline-Xgc:genparpar & Old, Young & -- & ++ & gen& parallel & parallel \\\hline
  genconpar &-Xgc:genconpar&Old, Young&+&+&gen& konk. & parallel \\\hline
  genparcon &-Xgc:genparcon&Old, Young&+&+&gen& parallel & konk. \\\hline
  singleconpar &-Xgc:singleconpar&-&+&+&single&konk. & parallel \\\hline
  singleparcon& -Xgc:singleparcon&-&+&+&single&parallel & konk. \\\hline
\caption{Übersicht der Garbage Collection Algorithmen}
  \end{longtable}

\section{Garbage Collection Logdateien}\label{jrockitgclog}
Die Auswertung der Garbage Collection findet auf Basis von Logdateien statt. Das Format dieser Logdateien hängt mitunter auch von den aktivierten Log-Modulen der JRockit Virtual Machine ab. Der Aufbau der Logdateien und die in der Analyse verwendeten Daten werden in diesem Abschnitt genauer beleuchtet.

\subsection{Aktivierung Log Ausgaben}
Defaultmässig macht die JRockit keine Angaben darüber, wie sie die Garbage Collection durchführt. Um an diese Informationen zu gelangen, muss das entsprechende Log-Module beim Start der Applikation aktiviert werden. Die Ausgaben werden dann auf die Standard Ausgabe geschrieben - können aber optional mit dem Argument -Xverboselog:logdatei.log in eine Datei umgeleitet werden. Das Format für die Kommandozeile sieht folgendermassen aus:

\begin{lstlisting}[caption=Format Aktivierung Log Modul]
-Xverbose:<modul>[=log_level]
\end{lstlisting}

Um das Memory Log Modul (gibt Informationen über die Garbage Collection aus) zu aktivieren:
\begin{lstlisting}[caption=Garbage Collection Log (Info)]
-Xverbose:memory
\end{lstlisting}

Die Umleitung der Ausgaben in eine separate Logdatei kann mit dem Flag -Xverboselog:\$\{dateiname\} eingestellt werden:
\begin{lstlisting}[caption=Garbage Collection Log (Info) - Umleitung in gc.log]
-Xverbose:memory -Xverboselog:gc.log 
\end{lstlisting}


Zusätzlich kann pro Log-Modul der Log-Level eingestellt werden:
\begin{lstlisting}[caption=Einstellung des Log-Levels]
-Xverbose:memory=debug -Xverboselog:gc.log 
\end{lstlisting}
Die folgenden Log Level können aktiviert werden: quiet, error, warn, info, debug, trace. Für mehr Informationen siehe \cite{oracleJRockitR28CLR}.


\begin{landscape}\label{logexample}
Die ersten Zeilen einer Log-Datei mit eingeschaltetem Memory Modul sehen folgendermassen aus:
\begin{lstlisting}[caption=Garbage Collection Log]
[INFO ][memory ] GC mode: Garbage collection optimized for throughput, strategy: Generational Parallel Mark & Sweep.
[INFO ][memory ] Heap size: 65536KB, maximal heap size: 1048576KB, nursery size: 32768KB.
[INFO ][memory ] <start>-<end>: <type> <before>KB-><after>KB (<heap>KB), <time> ms, sum of pauses <pause> ms.
[INFO ][memory ] <start>  - start time of collection (seconds since jvm start).
[INFO ][memory ] <type>   - OC (old collection) or YC (young collection).
[INFO ][memory ] <end>    - end time of collection (seconds since jvm start).
[INFO ][memory ] <before> - memory used by objects before collection (KB).
[INFO ][memory ] <after>  - memory used by objects after collection (KB).
[INFO ][memory ] <heap>   - size of heap after collection (KB).
[INFO ][memory ] <time>   - total time of collection (milliseconds).
[INFO ][memory ] <pause>  - total sum of pauses during collection (milliseconds).
[INFO ][memory ]            Run with -Xverbose:gcpause to see individual phases.
[INFO ][memory ] [OC#1] 0.843-0.845: OC 428KB->78423KB (117108KB), 0.003 s, sum of pauses 1.614 ms, longest pause 1.614 ms.
[INFO ][memory ] [OC#2] 1.393-1.442: OC 78449KB->156488KB (233624KB), 0.049 s, sum of pauses 47.104 ms, longest pause 47.104 ms.
[INFO ][memory ] [YC#1] 1.494-1.496: YC 156524KB->156628KB (233624KB), 0.002 s, sum of pauses 1.670 ms, longest pause 1.670 ms.
[INFO ][memory ] [YC#2] 1.496-1.496: YC 156652KB->156755KB (233624KB), 0.001 s, sum of pauses 0.605 ms, longest pause 0.605 ms.
[INFO ][memory ] [YC#3] 1.497-1.497: YC 156780KB->156884KB (233624KB), 0.001 s, sum of pauses 0.602 ms, longest pause 0.602 ms.
[INFO ][memory ] [YC#4] 1.497-1.498: YC 156908KB->157011KB (233624KB), 0.001 s, sum of pauses 0.592 ms, longest pause 0.592 ms.
\end{lstlisting}
\end{landscape}

\subsection{Log Module}\label{logmodule}

Die folgende Tabelle beschreibt die für die Auswertung der Garbage Collection relevanten Module (alphabetisch sortiert). 

\begin{longtable}{|p{4cm}|p{9cm}|p{2cm}|}
  \hline
  \textbf{Modul} & \textbf{Beschreibung} & \textbf{Relevanz}\\\hline
  alloc & Informationen betreffend Speicher Allokation und ``Out-of-Memory'' & niedrig \\\hline
  compaction & zeigt abhängig vom Garbage Collection Algorithmus Informationen zur Kompaktierung& niedrig \\\hline
  gcheuristic & zeigt Informationen und Entscheidungen zur Garbage Collection Heuristik & mittel \\\hline
  gcpause & zeigt wann welche Pausen zwecks Garbage Collection gemacht wurden, wie lange sie gedauert haben. & mittel \\\hline
  gcreport & zeigt verschiedene Auswertungen (Anzahl Collections, Anzahl promotete Objekte, maximal promotete Objekte per Zyklus, totale Zeit, Durchschnittszeit, Maximale Zeit) der Garbage Collection zum aktuellen Lauf& niedrig \\\hline
  memory & zeigt Informationen zum Memory Management System wie Start-, Endzeitpunkt der Collection, Speicher bevor, nach Collection, Grösse des Heaps, etc.& \textbf{sehr hoch} \\\hline
  memdbg & zeigt debug Informationen zu Speicher belange& \textbf{hoch} \\\hline
  systemgc & zeigt Garbage Collections die durch System.gc() gestartet wurden. & niedrig \\\hline
    \caption{Beschreibung der verschiedenen relevanten Log Modulen}
\end{longtable}